wf := import("@platforma-sdk/workflow-tengo:workflow")
render := import("@platforma-sdk/workflow-tengo:render")
exec := import("@platforma-sdk/workflow-tengo:exec")
ll := import("@platforma-sdk/workflow-tengo:ll")
assets := import("@platforma-sdk/workflow-tengo:assets")
file := import("@platforma-sdk/workflow-tengo:file")
maps := import("@platforma-sdk/workflow-tengo:maps")
smart := import("@platforma-sdk/workflow-tengo:smart")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pcolumn := import("@platforma-sdk/workflow-tengo:pframes.pcolumn")
times := import("times")
json := import("json")
rand := import("rand")
text := import("text")

mixcrSw := assets.importSoftware("@platforma-open/milaboratories.software-mixcr:main")
jsonMergingTpl := assets.importTemplate(":json-merging")
toCamelCase := import(":formatText")

chainInfos := {
	"IGH": "IGHeavy",
	"IGL": "IGLight",
	"IGK": "IGLight",
	"TRB": "TCRBeta",
	"TRA": "TCRAlpha",
	"TRG": "TCRGamma",
	"TRD": "TCRDelta"
}

wf.body(func(args) {
	blockId := wf.blockId().getDataAsJson()
	chainConfigs := args.chainConfigs
	species := args.species
	cmdSpecies := toCamelCase.toCamelCase(species) + "_custom"
	taxonId := string(rand.intn(9000) + 1000)
	outputs := {}
	fileImports := {}
	libraryMap := {}
	debugOutputMap := {}
	fileImportsProgress := {}
	chains := []

	for chain, chainConfig in chainConfigs {
		libraryBuilderCmdBuilder := exec.builder().
			software(mixcrSw).
			secret("MI_LICENSE", "MI_LICENSE").
			arg("buildLibrary").
			arg("--species").arg(cmdSpecies).
			arg("--chain").arg(chain).
			arg("--taxon-id").arg(taxonId).
			arg("--debug")

		if chainConfig["V"].sourceType == "built-in" {
			libraryBuilderCmdBuilder.arg("--v-genes-from-species").arg(chainConfig["V"].builtInSpecies)
		} else if chainConfig["V"].sourceType == "fasta" {
			vImport := file.importFile(chainConfig["V"].fastaFile)
			fileImports[chainConfig["V"].fastaFile] = vImport
			fileImportsProgress[chainConfig["V"].fastaFile] = vImport.handle
			libraryBuilderCmdBuilder.arg("--v-gene-feature").arg("VRegion").
				arg("--v-genes-from-fasta").arg("v.fasta").
				addFile("v.fasta", vImport.file)
		}

		if chainConfig["J"].sourceType == "built-in" {
			libraryBuilderCmdBuilder.arg("--j-genes-from-species").arg(chainConfig["J"].builtInSpecies)
		} else if chainConfig["J"].sourceType == "fasta" {
			jImport := file.importFile(chainConfig["J"].fastaFile)
			fileImports[chainConfig["J"].fastaFile] = jImport
			fileImportsProgress[chainConfig["J"].fastaFile] = jImport.handle
			libraryBuilderCmdBuilder.arg("--j-genes-from-fasta").arg("j.fasta").
				addFile("j.fasta", jImport.file)
		}

		if chainConfig["D"].builtInSpecies != undefined || chainConfig["D"].fastaFile != undefined {
			if chainConfig["D"].sourceType == "built-in" {
				libraryBuilderCmdBuilder.arg("--d-genes-from-species").arg(chainConfig["D"].builtInSpecies)
			} else if chainConfig["D"].sourceType == "fasta" {
				dImport := file.importFile(chainConfig["D"].fastaFile)
				fileImports[chainConfig["D"].fastaFile] = dImport
				fileImportsProgress[chainConfig["D"].fastaFile] = dImport.handle
				libraryBuilderCmdBuilder.arg("--d-genes-from-fasta").arg("d.fasta").
					addFile("d.fasta", dImport.file)
			}
		}

		if chainConfig["C"].builtInSpecies != undefined || chainConfig["C"].fastaFile != undefined {
			if chainConfig["C"].sourceType == "built-in" {
				libraryBuilderCmdBuilder.arg("--c-genes-from-species").arg(chainConfig["C"].builtInSpecies)
			} else if chainConfig["C"].sourceType == "fasta" {
				cImport := file.importFile(chainConfig["C"].fastaFile)
				fileImports[chainConfig["C"].fastaFile] = cImport
				fileImportsProgress[chainConfig["C"].fastaFile] = cImport.handle
				libraryBuilderCmdBuilder.arg("--c-genes-from-fasta").arg("c.fasta").
					addFile("c.fasta", cImport.file)
			}
		}

		libraryBuilderCmdBuilder.arg("library_" + chain + ".json").
			saveFile("library_" + chain + ".json").
			printErrStreamToStdout()
		libraryBuilderCmd := libraryBuilderCmdBuilder.run()
		
		debugOutput := libraryBuilderCmd.getStdoutStream()
		library := libraryBuilderCmd.getFile("library_" + chain + ".json")
		libraryMap["library_" + chain + ".json"] = library
		debugOutputMap[chain] = debugOutput
		chains = append(chains, chainInfos[chain])
	}

	seen := {}
	chains_unique := []
	for chain in chains {
		if !seen[chain] {
			seen[chain] = true
			chains_unique = append(chains_unique, chain)
		}
	}

	// Create logs map using pcolumn.resourceMapBuilder
	debugOutputMapBuilder := pcolumn.resourceMapBuilder(/* keyLength */ 1)
	for chain, debugOutput in debugOutputMap {
		debugOutputMapBuilder.add([chain], debugOutput)
	}

	outputs.debugOutput = debugOutputMapBuilder.build()

	outputs.fileImports = smart.createMapResource(maps.mapValues(fileImportsProgress, func(handle) {
		return handle
	}))

	mergeResults := render.create(jsonMergingTpl, {
		libraryMap: libraryMap
	})

	finalLibrary := mergeResults.output("library", 24 * 60 * 60 * 1000)

	ll.print("__THE_LOG__"+string(chains))

	exports := {
		library: {
			data: finalLibrary,
			spec: {
				kind: "File",
				name: "pl7.app/vdj/library",
				domain: {
					"pl7.app/vdj/libraryId": blockId
				},
				annotations: {
					"pl7.app/species": cmdSpecies,
					"pl7.app/vdj/chain": string(chains),
					"pl7.app/vdj/isLibrary": "true",
					"pl7.app/vdj/libraryFormat": "repseqio.json",
					"pl7.app/label": text.split(species, "_custom")[0] + " library"
				}
			}
		}
	}
	
	return {
		outputs: outputs,
		exports: exports
	}
})

